#include <stdio.h>
#include <stdbool.h>
#include <sys/times.h>
#include <time.h>
#include "utility/errors.h"
#include "filehandler.h"
#include "comment_remover.h"
#include "grammar/cfg.h"
#include "grammar/grammar_populator/constructor.h"
#include "compiler/symbol_table/constructor/symbol_table_constructor.h"
#include "grammar/first_follow/first.h"
#include "grammar/first_follow/follow.h"
#include "core/parse_table/parse_table.h"
#include "core/interface/parser.h"
#include "lexer/constructor/lexer_constructor.h"
#include "core/ast/ast.h"
#include "symbol_table/interface/symbol_table.h"
#include "core/parse_tree/parse_tree.h"
#include "semantic_analyzer/semantic_analyzer.h"

char *state_to_token_path = "files/lexer_files/mini_id_to_token_type.txt";
char *edges_path = "files/lexer_files/mini_edges.txt";
char *ac_retract_path = "files/lexer_files/mini_accept_retract_other.txt";
char *productions_path = "files/grammar_files/mini_productions.txt";
char *state_to_error = "files/lexer_files/state_to_error.txt";

static void handle_remove_comments_request(char *path);

static void handle_time_request(char *src, char *parse_out, int buffer_size);

static void handle_lexer_request(char *src);

static void handle_parser_request(char *src);

static void handle_ast_print(char *src);

static void handle_symbol_table_print(char *src);

static void handle_compression_ratio(char *src);

static void handle_total_memory_requirement(char *src);

static void handle_array_variable_print(char *src);

static void handle_syntax_and_semantic_error(char *src);

static void handle_code_generation(char *src, char *asm_out);

int main(int argc, char **argv) {
    /*
     * The command line argument for execution of the driver should be as follows, for example
     * $./stage1exe testcase.txt  parsetreeOutFile.txt  size_of_buffer
     */
    if (argc != 3) {
        printf("Execution Syntax ./compiler testcase.txt code.asm");
        return ERROR_INVALID_ARGS;
    }
    char *testcase = argv[1];
    char *asm_out = argv[2];
    int buffer_size = 1024;
//    char *testcase = "/Users/wint/code/compiler/files/testcases/own/t7.txt";
//    char *asm_out = "parse_tree.txt";
    int choice;
    while (true) {
        puts("Options: ");
        puts("0: For exit");
        puts("1: For printing the token list (on the console) generated by the lexer.");
        puts("2: For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console).");
        puts("3: For printing the Abstract Syntax Tree. Also specify the traversal order at the beginning. (On Console)");
        puts("4: For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used.");
        puts("5: For printing the Symbol Table for each variable identifier.");
        puts("6: For printing the total memory requirement.");
        puts("7: For printing the type expressions and width of array variables in a line for a test case.");
        puts("8: For compiling to verify the syntactic and semantic correctness of the input source code.");
        puts("9:  For producing assembly code");
        scanf("%d", &choice);

        switch (choice) {
            case 0:
                return ERROR_OK;
            case 1:
                handle_lexer_request(testcase);
                continue;
            case 2:
                handle_parser_request(testcase);
                continue;
            case 3:
                handle_ast_print(testcase);
            case 4:
                handle_compression_ratio(testcase);
                continue;
            case 5:
                handle_symbol_table_print(testcase);
                continue;
            case 6:
                handle_total_memory_requirement(testcase);
                continue;
            case 7:
                handle_array_variable_print(testcase);
                continue;
            case 8:
                handle_syntax_and_semantic_error(testcase);
                continue;
            case 9:
                handle_code_generation(testcase, asm_out);
                continue;
            default:
                puts("Invalid key pressed. Retry.");
                continue;
        }
    }
}


static void handle_lexer_request(char *src) {

    const Grammar *grammar = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(grammar);
    set_follow_sets_for(grammar);
    int buffer_size = 1024;
    Parser *interface = get_initialized_parser(grammar);
    Lexer *lexer = get_initialized_lexer_for_parser(interface, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    interface->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, interface->grammar->string_to_terminal_map);
    initialize_parser_symbol_table(interface);
    grant_symbol_table_to_lexer(interface->lexer, interface->symbol_table);
    run_lexer_independently_on_and_print_to(lexer, stdout);
}

static void handle_parser_request(char *src) {
    const Grammar *grammar = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(grammar);
    set_follow_sets_for(grammar);
    int buffer_size = 1024;
    Parser *interface = get_initialized_parser(grammar);
    Lexer *lexer = get_initialized_lexer_for_parser(interface, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    interface->lexer = lexer;

    set_string_to_token_type_map_for_lexer(lexer, interface->grammar->string_to_terminal_map);
    //  set_token_type_to_string_map_for_lexer(lexer, interface->grammar->terminal_to_string_map);

    initialize_parser_symbol_table(interface);
    grant_symbol_table_to_lexer(interface->lexer, interface->symbol_table);

    ParseTree *parse_tree = get_parse_tree(interface);
    print_parse_tree(interface, parse_tree, stdout);
}

static void handle_compression_ratio(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);
    // print_symbol_table(interface->symbol_table);
    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    get_parse_tree(parser);
    printf("Parse Tree Number of Nodes = %d, Allocated Memory = %d\n", parse_tree_number_of_nodes,
           parse_tree_allocated_memory);
    printf("AST Number of Nodes = %d, Allocated Memory = %d\n", ast_number_of_nodes,
           ast_allocated_memory);
    double compression_percentage =
            ((double) (parse_tree_allocated_memory - ast_allocated_memory)) / ((double) (parse_tree_allocated_memory));
    compression_percentage = compression_percentage * 100;
    printf("Compression Percentage = %lf\n", compression_percentage);
}

static void handle_ast_print(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);
    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    ParseTree *parse_tree = get_parse_tree(parser);
    ASTNode *program_node;
    pop_stack(parse_tree->semantic_stack, &program_node);
    printf("Preorder Traversal\n");
    print_ast_node(program_node, 0);
}

static void handle_symbol_table_print(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);
    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    ParseTree *parse_tree = get_parse_tree(parser);
    ASTNode *program_node;
    pop_stack(parse_tree->semantic_stack, &program_node);
    ProgramNode *pro = (ProgramNode *) program_node;
    // construct_symbol_table(pro);
    print_symbol_table_as_required(pro->global_symbol_table);
}

static void handle_total_memory_requirement(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);
    // print_symbol_table(interface->symbol_table);
    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    get_parse_tree(parser);
    printf("Parse Tree Number of Nodes = %d, Allocated Memory = %d\n", parse_tree_number_of_nodes,
           parse_tree_allocated_memory);
    printf("AST Number of Nodes = %d, Allocated Memory = %d\n", ast_number_of_nodes,
           ast_allocated_memory);
    double compression_percentage =
            ((double) (parse_tree_allocated_memory - ast_allocated_memory)) / ((double) (parse_tree_allocated_memory));
    compression_percentage = compression_percentage * 100;
    printf("Compression Percentage = %lf\n", compression_percentage);
}

static void handle_array_variable_print(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);
    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    ParseTree *parse_tree = get_parse_tree(parser);
    ASTNode *program_node;
    pop_stack(parse_tree->semantic_stack, &program_node);
    ProgramNode *pro = (ProgramNode *) program_node;
    // construct_symbol_table(pro);
    print_array_variable_entry(pro->global_symbol_table);
}

static void handle_syntax_and_semantic_error(char *src) {
    const Grammar *g = get_initialized_grammar("/Users/wint/code/compiler/files/grammar_files/mini_productions.txt");
    set_first_sets_for(g);
    set_follow_sets_for(g);
    Parser *parser = get_initialized_parser(g);
    int buffer_size = 1024;
    Lexer *lexer = get_initialized_lexer_for_parser(parser, src, state_to_token_path, edges_path,
                                                    ac_retract_path,
                                                    state_to_token_path, state_to_error, buffer_size);
    parser->lexer = lexer;
    set_string_to_token_type_map_for_lexer(lexer, parser->grammar->string_to_terminal_map);

    initialize_parser_symbol_table(parser);

    grant_symbol_table_to_lexer(parser->lexer, parser->symbol_table);
    ParseTree *parse_tree = get_parse_tree(parser);
    ASTNode *program_node;
    pop_stack(parse_tree->semantic_stack, &program_node);
    ProgramNode *pro = (ProgramNode *) program_node;
    // construct_symbol_table(pro);
    perform_semantic_analysis(pro, pro->global_symbol_table);
}

static void handle_code_generation(char *src, char *asm_out) {

}

//static void handle_time_request(char *src, char *parse_out, int buffer_size) {
//    clock_t begin = clock();
//
//    // Find time taken
//    Grammar *grammar = initialize_grammar_from(terminals_path, non_terminals_path, keywords_path, productions_path);
//    set_first_sets_for(grammar);
//    set_follow_sets_for(grammar);
//    Parser *interface = get_initialized_parser(grammar);
//    Lexer *lexer = get_initialized_lexer_for_parser(interface, src, state_to_token_path, edges_path,
//                                                    ac_retract_path,
//                                                    state_to_token_path, state_to_error, buffer_size);
//    interface->lexer = lexer;
//    set_string_to_token_type_map_for_lexer(lexer, interface->grammar->string_to_terminal_map);
//    set_token_type_to_string_map_for_lexer(lexer, interface->grammar->terminal_to_string_map);
//
//    initialize_parser_symbol_table(interface);
//    grant_symbol_table_to_lexer(interface->lexer, interface->symbol_table);
////    ParseTree *parse_tree = get_parse_tree(interface); // FIND TIME TO CONSTRUCT THIS PARSE TREE
////    print_parse_tree(interface, parse_tree, stdout);
//
//    clock_t end = clock();
//    size_t ticks = end - begin;
//    double time_spent = (double) (end - begin) / CLOCKS_PER_SEC;
//    printf("CPU Time executed to initialize lexer, interface"
//           " + construct parse tree (i.e. time used by interface + lexer to create it)"
//           " + print it to parse_out file =\n1) %f seconds\n2) %zu ticks\n",
//           time_spent, ticks);
//}